name: Deploy to Server

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      clean_deploy:
        description: 'Force clean deployment (stop and remove all containers, keep data)'
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    name: Deploy to docker.fwv-raura.ch
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Trim whitespace from SERVER_HOST secret
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          ssh-keyscan -H "${SERVER_HOST}" >> ~/.ssh/known_hosts

      - name: Clean deployment (remove all containers, keep data)
        run: |
          echo "ðŸ§¹ Starting clean deployment - removing all containers while preserving data..."

          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          DEPLOY_PATH=$(echo "${{ secrets.DEPLOY_PATH }}" | xargs)

          ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" << ENDSSH
          cd "${DEPLOY_PATH}" || { echo "âš  DEPLOY_PATH not found - skipping clean"; exit 0; }

          if [ -f docker-compose.yml ]; then
            echo "ðŸ›‘ Stopping all containers..."
            docker-compose down --remove-orphans

            echo "ðŸ—‘ï¸ Removing unused Docker resources..."
            docker system prune -f

            echo "âœ… Clean deployment preparation complete - all containers removed, data preserved"
          else
            echo "âš  No docker-compose.yml found - skipping clean"
          fi
          ENDSSH

      - name: Check server and service health
        id: check_setup
        run: |
          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          DEPLOY_PATH=$(echo "${{ secrets.DEPLOY_PATH }}" | xargs)

          # Check if Docker is installed
          if ! ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" 'command -v docker &> /dev/null'; then
            echo "setup_needed=true" >> $GITHUB_OUTPUT
            echo "âš  Docker not found - full server setup will be performed"
            exit 0
          fi

          echo "âœ“ Docker is installed"

          # Check if docker-compose.yml exists
          if ! ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" "[ -f ${DEPLOY_PATH}/docker-compose.yml ]"; then
            echo "setup_needed=false" >> $GITHUB_OUTPUT
            echo "âš  Docker Compose file not found - initial deployment needed"
            exit 0
          fi

          echo "âœ“ Docker Compose file exists"

          # Check container health
          echo "Checking container health..."
          HEALTH_CHECK=$(ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" "cd ${DEPLOY_PATH} && docker-compose ps --format json 2>/dev/null" || echo "ERROR")

          if [ "$HEALTH_CHECK" = "ERROR" ]; then
            echo "setup_needed=false" >> $GITHUB_OUTPUT
            echo "âš  Cannot check container status - deployment will proceed"
            exit 0
          fi

          # Count unhealthy containers (containers with Health status that is not "healthy" or empty)
          UNHEALTHY=$(echo "$HEALTH_CHECK" | jq -r 'select(.Health != "healthy" and .Health != "" and .Health != null) | .Name' | wc -l)
          TOTAL=$(echo "$HEALTH_CHECK" | jq -r '.Name' | wc -l)

          echo "Found ${TOTAL} containers, ${UNHEALTHY} unhealthy"

          if [ "$UNHEALTHY" -gt 0 ]; then
            echo "setup_needed=false" >> $GITHUB_OUTPUT
            echo "âš  ${UNHEALTHY} container(s) unhealthy - redeployment needed"
            echo "Unhealthy containers:"
            echo "$HEALTH_CHECK" | jq -r 'select(.Health != "healthy" and .Health != "" and .Health != null) | "  - \(.Name): \(.Health)"'
          else
            echo "setup_needed=false" >> $GITHUB_OUTPUT
            echo "âœ… All ${TOTAL} containers are healthy - deployment will refresh services"
          fi

      - name: Run server setup (if needed)
        if: steps.check_setup.outputs.setup_needed == 'true'
        run: |
          echo "ðŸš€ Running initial server setup..."

          # Trim whitespace from secrets (removes newlines, spaces, etc.)
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)

          # Validate required secrets are set
          if [ -z "$SERVER_PORT" ]; then
            echo "Error: SERVER_PORT secret is not set"
            exit 1
          fi
          if [ -z "$SERVER_USER" ]; then
            echo "Error: SERVER_USER secret is not set"
            exit 1
          fi
          if [ -z "$SERVER_HOST" ]; then
            echo "Error: SERVER_HOST secret is not set"
            exit 1
          fi

          echo "Uploading setup script to server..."
          scp -P "${SERVER_PORT}" \
            setup-server.sh \
            "${SERVER_USER}@${SERVER_HOST}:/tmp/setup-server.sh"

          echo "Executing setup script on server..."
          ssh -p "${SERVER_PORT}" \
            "${SERVER_USER}@${SERVER_HOST}" << 'ENDSSH'
          chmod +x /tmp/setup-server.sh
          /tmp/setup-server.sh
          rm /tmp/setup-server.sh
          ENDSSH

          echo "âœ“ Server setup completed successfully"

      - name: Create deployment structure
        run: |
          mkdir -p n8n/data
          mkdir -p nextcloud/db
          mkdir -p nextcloud/html
          mkdir -p nextcloud/data
          mkdir -p nextcloud/config
          mkdir -p nextcloud/apps
          mkdir -p portainer/data
          mkdir -p authentik/postgresql
          mkdir -p authentik/redis
          mkdir -p authentik/media/public
          mkdir -p authentik/certs
          mkdir -p authentik/custom-templates
          mkdir -p crowdsec/config
          mkdir -p crowdsec/data
          mkdir -p crowdsec/traefik-logs

      - name: Deploy files to server
        run: |
          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          DEPLOY_PATH=$(echo "${{ secrets.DEPLOY_PATH }}" | xargs)

          rsync -avz --delete \
            -e "ssh -p ${SERVER_PORT}" \
            --exclude '.git' \
            --exclude '.github' \
            --exclude '.env' \
            --exclude 'traefik/acme.json' \
            --exclude 'n8n/data/*' \
            --exclude 'nextcloud/db/*' \
            --exclude 'nextcloud/html/*' \
            --exclude 'nextcloud/data/*' \
            --exclude 'nextcloud/config/*' \
            --exclude 'nextcloud/apps/*' \
            --exclude 'portainer/data/*' \
            --exclude 'authentik/postgresql/*' \
            --exclude 'authentik/redis/*' \
            --exclude 'authentik/media/*' \
            --exclude 'authentik/certs/*' \
            --exclude 'authentik/custom-templates/*' \
            --exclude 'crowdsec/config/*' \
            --exclude 'crowdsec/data/*' \
            --exclude 'README.md' \
            --exclude 'CROWDSEC.md' \
            --exclude 'AUTHENTIK-INTEGRATION.md' \
            ./ "${SERVER_USER}@${SERVER_HOST}:${DEPLOY_PATH}/"

      - name: Fix directory permissions
        run: |
          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          DEPLOY_PATH=$(echo "${{ secrets.DEPLOY_PATH }}" | xargs)

          ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" << ENDSSH
          cd "${DEPLOY_PATH}" || { echo "Error: DEPLOY_PATH not found"; exit 1; }

          # Fix n8n permissions (needs to be writable by UID 1000)
          chown -R 1000:1000 n8n/data
          chmod -R 755 n8n/data

          # Fix Authentik media permissions (needs to be writable by UID 1000)
          chown -R 1000:1000 authentik/media
          chmod -R 755 authentik/media

          echo "âœ“ Directory permissions fixed"
          ENDSSH

      - name: Configure acme.json permissions
        run: |
          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          DEPLOY_PATH=$(echo "${{ secrets.DEPLOY_PATH }}" | xargs)

          ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" << ENDSSH
          cd "${DEPLOY_PATH}" || { echo "Error: DEPLOY_PATH not found"; exit 1; }
          mkdir -p traefik
          if [ ! -f traefik/acme.json ]; then
            touch traefik/acme.json
          fi
          chmod 600 traefik/acme.json
          ENDSSH

      - name: Create .env file from secrets
        run: |
          # Create .env file locally to avoid shell expansion issues with special characters
          cat > .env << 'EOF'
          # Domain Configuration
          DOMAIN_BASE=fwv-raura.ch
          TRAEFIK_DOMAIN=traefik.fwv-raura.ch
          PORTAINER_DOMAIN=portainer.fwv-raura.ch
          AUTHENTIK_DOMAIN=auth.fwv-raura.ch
          N8N_DOMAIN=n8n.fwv-raura.ch
          NEXTCLOUD_DOMAIN=cloud.fwv-raura.ch
          MAILCOW_DOMAIN=mail.fwv-raura.ch

          # Timezone
          TIMEZONE=Europe/Zurich
          EOF

          # Append secrets
          # TRAEFIK_BASIC_AUTH from GitHub Secret
          # Generate with: htpasswd -nbB admin yourpassword | sed 's/\$/\$\$/g'
          # Store the result (with $$ for Docker Compose) in the GitHub Secret
          # Use printf with %s to prevent shell interpretation of $$
          printf 'TRAEFIK_BASIC_AUTH=%s\n' '${{ secrets.TRAEFIK_BASIC_AUTH }}' >> .env
          echo "" >> .env
          echo "# n8n Basic Auth" >> .env
          echo "N8N_BASIC_AUTH_USER=${{ secrets.N8N_BASIC_AUTH_USER }}" >> .env
          echo "N8N_BASIC_AUTH_PASSWORD=${{ secrets.N8N_BASIC_AUTH_PASSWORD }}" >> .env
          echo "" >> .env
          echo "# Nextcloud Database" >> .env
          echo "NEXTCLOUD_DB_ROOT_PASSWORD=${{ secrets.NEXTCLOUD_DB_ROOT_PASSWORD }}" >> .env
          echo "NEXTCLOUD_DB_PASSWORD=${{ secrets.NEXTCLOUD_DB_PASSWORD }}" >> .env
          echo "" >> .env
          echo "# Nextcloud Admin" >> .env
          echo "NEXTCLOUD_ADMIN_USER=${{ secrets.NEXTCLOUD_ADMIN_USER }}" >> .env
          echo "NEXTCLOUD_ADMIN_PASSWORD=${{ secrets.NEXTCLOUD_ADMIN_PASSWORD }}" >> .env
          echo "" >> .env
          echo "# Authentik" >> .env
          echo "AUTHENTIK_SECRET_KEY=${{ secrets.AUTHENTIK_SECRET_KEY }}" >> .env
          echo "AUTHENTIK_ERROR_REPORTING=false" >> .env
          echo "AUTHENTIK_POSTGRESQL_PASSWORD=${{ secrets.AUTHENTIK_POSTGRESQL_PASSWORD }}" >> .env
          echo "AUTHENTIK_POSTGRESQL_USER=authentik" >> .env
          echo "AUTHENTIK_POSTGRESQL_NAME=authentik" >> .env
          echo "" >> .env
          echo "# CrowdSec" >> .env
          echo "CROWDSEC_BOUNCER_KEY_TRAEFIK=${{ secrets.CROWDSEC_BOUNCER_KEY_TRAEFIK }}" >> .env
          echo "" >> .env
          echo "# SMTP/Email Configuration (used by Watchtower, Postfix, Authentik, and other services)" >> .env
          echo "EMAIL_FROM=${{ secrets.EMAIL_FROM }}" >> .env
          echo "EMAIL_TO=${{ secrets.EMAIL_TO }}" >> .env
          echo "SMTP_SERVER=${{ secrets.SMTP_SERVER }}" >> .env
          echo "SMTP_PORT=${{ secrets.SMTP_PORT }}" >> .env
          echo "SMTP_USER=${{ secrets.SMTP_USER }}" >> .env
          echo "SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}" >> .env

          # Upload .env file to server
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          DEPLOY_PATH=$(echo "${{ secrets.DEPLOY_PATH }}" | xargs)

          scp -P "${SERVER_PORT}" .env "${SERVER_USER}@${SERVER_HOST}:${DEPLOY_PATH}/.env"

          # Set correct permissions
          ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" "chmod 600 ${DEPLOY_PATH}/.env"

          # Clean up local .env
          rm .env

      - name: Configure email notifications for system updates
        run: |
          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)

          # Store SMTP config in variables for transfer
          SMTP_SERVER="${{ secrets.SMTP_SERVER }}"
          SMTP_PORT="${{ secrets.SMTP_PORT }}"
          SMTP_USER="${{ secrets.SMTP_USER }}"
          SMTP_PASSWORD="${{ secrets.SMTP_PASSWORD }}"
          EMAIL_TO="${{ secrets.EMAIL_TO }}"

          # Create temporary config files locally
          cat > /tmp/postfix_main.cf << 'EOF'
          # Basic Postfix configuration
          smtpd_banner = $myhostname ESMTP
          biff = no
          append_dot_mydomain = no
          readme_directory = no
          compatibility_level = 2

          # SMTP relay configuration
          relayhost = [SMTP_SERVER_PLACEHOLDER]:SMTP_PORT_PLACEHOLDER
          smtp_use_tls = yes
          smtp_sasl_auth_enable = yes
          smtp_sasl_security_options = noanonymous
          smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd
          smtp_tls_CAfile = /etc/ssl/certs/ca-certificates.crt
          smtp_tls_security_level = encrypt

          # Network settings
          inet_interfaces = loopback-only
          inet_protocols = ipv4
          mydestination = localhost
          mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128
          EOF

          # Replace placeholders
          sed -i "s/SMTP_SERVER_PLACEHOLDER/${SMTP_SERVER}/g" /tmp/postfix_main.cf
          sed -i "s/SMTP_PORT_PLACEHOLDER/${SMTP_PORT}/g" /tmp/postfix_main.cf

          # Create SASL password file locally
          echo "[${SMTP_SERVER}]:${SMTP_PORT} ${SMTP_USER}:${SMTP_PASSWORD}" > /tmp/postfix_sasl_passwd

          # Transfer files to server
          scp -P "${SERVER_PORT}" /tmp/postfix_main.cf "${SERVER_USER}@${SERVER_HOST}:/tmp/postfix_main.cf"
          scp -P "${SERVER_PORT}" /tmp/postfix_sasl_passwd "${SERVER_USER}@${SERVER_HOST}:/tmp/postfix_sasl_passwd"

          # Clean up local temp files
          rm /tmp/postfix_main.cf /tmp/postfix_sasl_passwd

          # Configure on server
          ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" bash << ENDSSH
          # Install Postfix configuration
          mv /tmp/postfix_main.cf /etc/postfix/main.cf
          mv /tmp/postfix_sasl_passwd /etc/postfix/sasl_passwd
          chmod 600 /etc/postfix/sasl_passwd
          postmap /etc/postfix/sasl_passwd

          # Configure root email forwarding to admin
          echo "root: ${EMAIL_TO}" > /etc/aliases
          newaliases

          # Restart Postfix
          systemctl restart postfix
          systemctl enable postfix

          echo "âœ“ Email notifications configured - System updates will report errors to ${EMAIL_TO}"
          ENDSSH

      - name: Create Docker networks
        run: |
          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)

          ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" << 'ENDSSH'
          docker network create proxy 2>/dev/null || true
          docker network create nextcloud 2>/dev/null || true
          docker network create authentik 2>/dev/null || true
          ENDSSH

      - name: Pull and restart containers
        run: |
          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          DEPLOY_PATH=$(echo "${{ secrets.DEPLOY_PATH }}" | xargs)

          ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" << ENDSSH
          cd "${DEPLOY_PATH}" || { echo "Error: DEPLOY_PATH not found"; exit 1; }
          docker-compose pull
          docker-compose up -d --remove-orphans
          docker-compose ps
          ENDSSH

      - name: Show deployment info
        run: |
          echo "âœ… Deployment erfolgreich!"
          echo ""
          echo "Services:"
          echo "  - Traefik: https://traefik.fwv-raura.ch"
          echo "  - Portainer: https://portainer.fwv-raura.ch"
          echo "  - Authentik: https://auth.fwv-raura.ch"
          echo "  - n8n: https://n8n.fwv-raura.ch"
          echo "  - Nextcloud: https://cloud.fwv-raura.ch"

      - name: Check container health
        run: |
          # Trim whitespace from secrets
          SERVER_PORT=$(echo "${{ secrets.SERVER_PORT }}" | xargs)
          SERVER_USER=$(echo "${{ secrets.SERVER_USER }}" | xargs)
          SERVER_HOST=$(echo "${{ secrets.SERVER_HOST }}" | xargs)
          DEPLOY_PATH=$(echo "${{ secrets.DEPLOY_PATH }}" | xargs)

          ssh -p "${SERVER_PORT}" "${SERVER_USER}@${SERVER_HOST}" << ENDSSH
          cd "${DEPLOY_PATH}" || { echo "Error: DEPLOY_PATH not found"; exit 1; }
          echo "Container Status:"
          docker-compose ps
          echo ""
          echo "Running Containers:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          ENDSSH
